# March 6.th Compiler Notes #   
  
## Chapter 3: Syntactic Parsing 1 (Top-Down Parsing) ##  
  
### CFLs:  
 **Domain:**  
    - All RLs, and also Non-RLs | ex: (a^n)*(b^n) , #a=#b, etc... |   
    - Operates on a [STACK] basis:   
        - Push, Pop, Top -> LIFO    
    - Accepted by a `CFG` , also generated by one!  
    - Accepted by some `Pushdown Automata (PDA)`  
 **Grammars:**  
    - A set of rules that a `CFL` abides by  
    - Expressed as a `CFG`  
  
### CFGs:   
 **4-Tuple G = (V,Σ,R,S)**  
     `Σ` | set of `Terminal Symbols`  
     `V` | set of `Non-Terminal Symbols` (aka Variables)  
     `S` | the `Start Variable` s.t. `S ∈ V` (UNIQUE)  
     `R` | a `Finite Set`, who's elements are `Rules: {format: A → w}`  
 **Generated Languages L(G):**  
    let `G = (V,Σ,R,S)` be a `CFG`:  
        - the Language generated by G is `L(G) = {x ∈ Σ* | S =G> * x }`  
 **R:**  
    R = { S → ε | aSb | SS } ( `|` implies `or` or `,`)  
    
### Derivation Example:     
 **w.w.t.s abba ∈ pal:**  
    *Recursive CFG for Language pal :*  
        S → ε    
        S → bSb  
        S → aSa  
    *Derivation:*    
        1. S → aSa   (S → aSa)    
        2. S → abSba (S → bSb)  
        3. S → abba  (S → ε)  
 **THEOREM 1:**  
    if `β =G> γ` exists, there exists a rule `(A → w) ∈ R` s.t:  
        1. `β = u A v`  
        2. `γ = u w v`  
        3. so, `uAv =G> uvw`  
  
### Parse Tree:  
 **How to Write:**  
    1. Parse an Entry Entity `E` into it's intividual `id` components  
        a. To do this, write `substrings` as `element-trees of E`  
        b. Do this until you reach the `id` element (terminal)  
  
### PARSERS!  
 **Required Methods:**  
    `1. Recognizer` | not all sequences of `tokens` are `programs`  
        - must distinguish between `valid` and `invalid` tokens   
    `2. Translator` | must `expose program structure`  
        - i.e: associativity and precedence  
        - hence must return the `syntax tree`  
 **Required Elements:**  
    `1. CFG`    | Method for `describing valid token sequences`  
    `2. Parser` | Method for `validating & building the sequence tree`  
  
### Parsers Introduction (not as important)  
 **NOTABLE INFO:**
    - The `syntactic analyzer / parser` -> Heart of the frontend compiler  
    - Most languages are Not Completely Described by `CFGs`
    - `Grammars` are most useful for developing `infinite sequences

### Chomsky Grammar Conventions:
 **CONVENTION METHODS:**
    - `non-terminals` | represented by CAPITAL LETTERS
    - `terminals`     | represented by lowercase letters    (a,b,c,etc-)  
    - `terminal-strings` | represented by lowercase letters (z,y,x,etc-)  
    - `mixed-content`    | represented by lowercase greek letters
